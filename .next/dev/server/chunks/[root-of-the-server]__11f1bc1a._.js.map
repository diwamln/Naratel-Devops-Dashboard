{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///home/duwa/Git/fix/Naratel-Devops-Dashboard/src/lib/gitMutex.js"],"sourcesContent":["import { Mutex } from 'async-mutex';\n\n// Shared mutex instance to prevent race conditions during Git operations\nexport const gitMutex = new Mutex();\n"],"names":[],"mappings":";;;;AAAA;;AAGO,MAAM,WAAW,IAAI,4LAAK"}},
    {"offset": {"line": 81, "column": 0}, "map": {"version":3,"sources":["file:///home/duwa/Git/fix/Naratel-Devops-Dashboard/src/app/api/manifest/secrets/route.js"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { execSync } from 'child_process';\nimport fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport yaml from 'js-yaml';\nimport { gitMutex } from '@/lib/gitMutex';\n\nexport const dynamic = 'force-dynamic';\n\nconst getRepoConfig = () => {\n    return {\n        repoDirName: 'manifest-repo-workdir',\n        repoPath: path.join(os.tmpdir(), 'manifest-repo-workdir'),\n        token: process.env.GITHUB_TOKEN,\n        repoUrl: process.env.MANIFEST_REPO_URL,\n        userName: process.env.GIT_USER_NAME || \"Naratel DevOps Dashboard\",\n        userEmail: process.env.GIT_USER_EMAIL || \"devops@naratel.com\",\n        agePubKey: process.env.SOPS_AGE_PUBKEY || \"age1ywhtcmyuhmfa32kfaaxcak4dvq27q9g6m55gqlzu2vlwkgfj24wq3g4ejx\"\n    };\n};\n\nconst readSecretKeys = (filePath) => {\n    if (!fs.existsSync(filePath)) return [];\n    try {\n        const content = fs.readFileSync(filePath, 'utf8');\n        const parsed = yaml.load(content);\n        const secrets = parsed.secretData || {};\n        return Object.keys(secrets);\n    } catch (e) {\n        console.error(`Failed to read keys from ${filePath}:`, e.message);\n        return [];\n    }\n};\n\nconst overwriteSecretFile = (filePath, newSecrets, agePubKey) => {\n    const dir = path.dirname(filePath);\n    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\n\n    try {\n        const cleanSecrets = {};\n        // newSecrets is an array of {key, value} or object\n        // The API sends array of {key, value}.\n        if (Array.isArray(newSecrets)) {\n            newSecrets.forEach(s => {\n                if (s.key && s.value !== undefined) cleanSecrets[s.key] = s.value;\n            });\n        } else {\n            Object.entries(newSecrets).forEach(([k, v]) => {\n                if (v !== undefined) cleanSecrets[k] = v;\n            });\n        }\n\n        const doc = { secretData: cleanSecrets };\n        const newYaml = yaml.dump(doc, { lineWidth: -1 });\n        fs.writeFileSync(filePath, newYaml);\n\n        execSync(`sops --encrypt --age ${agePubKey} --encrypted-regex '^(secretData)$' --in-place \"${filePath}\"`);\n    } catch (e) {\n        throw new Error(`Failed to overwrite ${path.basename(filePath)}: ${e.message}`);\n    }\n};\n\nexport async function GET(req) {\n    const { searchParams } = new URL(req.url);\n    const appName = searchParams.get('appName');\n    if (!appName) return NextResponse.json({ error: \"App Name required\" }, { status: 400 });\n\n    return await gitMutex.runExclusive(async () => {\n        const { repoPath, repoUrl, token, userName, userEmail } = getRepoConfig();\n        const authenticatedUrl = repoUrl.replace(\"https://\", `https://${token}@`);\n\n        try {\n            if (!fs.existsSync(repoPath)) {\n                execSync(`git clone ${authenticatedUrl} ${repoPath}`);\n            } else {\n                try {\n                    execSync(`git fetch origin`, { cwd: repoPath });\n                    execSync(`git reset --hard origin/main`, { cwd: repoPath });\n                } catch (e) {\n                    fs.rmSync(repoPath, { recursive: true, force: true });\n                    execSync(`git clone ${authenticatedUrl} ${repoPath}`);\n                }\n            }\n            execSync(`git config user.name \"${userName}\"`, { cwd: repoPath });\n            execSync(`git config user.email \"${userEmail}\"`, { cwd: repoPath });\n\n            const appsPath = path.join(repoPath, 'apps');\n            const registryPath = path.join(repoPath, 'registry.json');\n            \n            let appId = null;\n            if (fs.existsSync(registryPath)) {\n                try {\n                    const registry = JSON.parse(fs.readFileSync(registryPath, 'utf8'));\n                    const appEntry = registry.find(a => a.name === appName);\n                    if (appEntry) appId = appEntry.id;\n                } catch (e) { console.error(\"Failed to parse registry\", e); }\n            }\n\n            // Define Paths\n            let appProdPath = path.join(appsPath, `${appId}-${appName}-prod`, 'secrets.yaml');\n            let appTestPath = path.join(appsPath, `${appId}-${appName}-testing`, 'secrets.yaml');\n            \n            let dbProdPath = path.join(appsPath, `${appId}-db-${appName}-prod`, 'secrets.yaml');\n            let dbTestPath = path.join(appsPath, `${appId}-db-${appName}-testing`, 'secrets.yaml');\n\n            // Legacy Fallback\n            if (!fs.existsSync(path.dirname(appProdPath))) {\n                appProdPath = path.join(appsPath, `${appName}-prod`, 'secrets.yaml');\n                // Assume legacy structure implies legacy testing path too if exists\n                appTestPath = path.join(appsPath, `${appName}-testing`, 'secrets.yaml');\n            }\n            if (!fs.existsSync(path.dirname(dbProdPath))) {\n                dbProdPath = path.join(appsPath, `${appName}-db-prod`, 'secrets.yaml');\n                dbTestPath = path.join(appsPath, `${appName}-db-testing`, 'secrets.yaml');\n            }\n\n            // Read Keys\n            const appKeysProd = readSecretKeys(appProdPath);\n            const appKeysTest = readSecretKeys(appTestPath);\n            const dbKeysProd = readSecretKeys(dbProdPath);\n            const dbKeysTest = readSecretKeys(dbTestPath);\n\n            // Merge Unique Keys\n            const mergeKeys = (keysA, keysB) => Array.from(new Set([...keysA, ...keysB]));\n            \n            const appAllKeys = mergeKeys(appKeysProd, appKeysTest);\n            const dbAllKeys = mergeKeys(dbKeysProd, dbKeysTest);\n\n            const appSecrets = appAllKeys.map(k => ({ key: k }));\n            const dbSecrets = dbAllKeys.map(k => ({ key: k }));\n\n            return NextResponse.json({\n                appSecrets,\n                dbSecrets,\n                hasDb: fs.existsSync(path.dirname(dbProdPath))\n            });\n\n        } catch (err) {\n            console.error(err);\n            return NextResponse.json({ error: err.message }, { status: 500 });\n        }\n    });\n}\n\nexport async function POST(req) {\n    const { appName, appSecrets, appSecretsTest, dbSecrets, dbSecretsTest } = await req.json();\n    if (!appName) return NextResponse.json({ error: \"Missing App Name\" }, { status: 400 });\n\n    return await gitMutex.runExclusive(async () => {\n        const { repoPath, repoUrl, token, userName, userEmail, agePubKey } = getRepoConfig();\n        const authenticatedUrl = repoUrl.replace(\"https://\", `https://${token}@`);\n\n        try {\n            if (!fs.existsSync(repoPath)) {\n                execSync(`git clone ${authenticatedUrl} ${repoPath}`);\n            } else {\n                 try {\n                    execSync(`git fetch origin`, { cwd: repoPath });\n                    execSync(`git reset --hard origin/main`, { cwd: repoPath });\n                } catch (e) {\n                    fs.rmSync(repoPath, { recursive: true, force: true });\n                    execSync(`git clone ${authenticatedUrl} ${repoPath}`);\n                }\n            }\n            execSync(`git config user.name \"${userName}\"`, { cwd: repoPath });\n            execSync(`git config user.email \"${userEmail}\"`, { cwd: repoPath });\n\n            const appsPath = path.join(repoPath, 'apps');\n            const registryPath = path.join(repoPath, 'registry.json');\n            \n            let appId = null;\n            if (fs.existsSync(registryPath)) {\n                try {\n                    const registry = JSON.parse(fs.readFileSync(registryPath, 'utf8'));\n                    const appEntry = registry.find(a => a.name === appName);\n                    if (appEntry) appId = appEntry.id;\n                } catch (e) { console.error(\"Failed to parse registry\", e); }\n            }\n            \n            const getPaths = (type) => {\n                let prod = path.join(appsPath, `${appId}-${type === 'db' ? 'db-' : ''}${appName}-prod`, 'secrets.yaml');\n                let test = path.join(appsPath, `${appId}-${type === 'db' ? 'db-' : ''}${appName}-testing`, 'secrets.yaml');\n                \n                // Legacy check\n                if (!fs.existsSync(path.dirname(prod))) {\n                    prod = path.join(appsPath, `${type === 'db' ? '' : ''}${appName}${type === 'db' ? '-db' : ''}-prod`, 'secrets.yaml'); // Naming was inconsistent? Assuming consistent new naming.\n                    // Fallback to simpler check:\n                    if (!fs.existsSync(path.dirname(path.join(appsPath, `${appId}-${type === 'db' ? 'db-' : ''}${appName}-prod`)))) {\n                         // Attempt legacy\n                         const legacyBase = path.join(appsPath, `${appName}${type === 'db' ? '-db' : ''}`);\n                         prod = legacyBase + '-prod/secrets.yaml';\n                         test = legacyBase + '-testing/secrets.yaml';\n                    }\n                }\n                return { prod, test };\n            };\n\n            // APP SECRETS\n            const appPaths = getPaths('app');\n            if (appSecrets && appSecrets.length > 0) overwriteSecretFile(appPaths.prod, appSecrets, agePubKey);\n            if (appSecretsTest && appSecretsTest.length > 0) overwriteSecretFile(appPaths.test, appSecretsTest, agePubKey);\n\n            // DB SECRETS\n            const dbPaths = getPaths('db');\n            if (dbSecrets && dbSecrets.length > 0) overwriteSecretFile(dbPaths.prod, dbSecrets, agePubKey);\n            if (dbSecretsTest && dbSecretsTest.length > 0) overwriteSecretFile(dbPaths.test, dbSecretsTest, agePubKey);\n\n            execSync(`git add .`, { cwd: repoPath });\n            const status = execSync(`git status --porcelain`, { cwd: repoPath }).toString();\n            \n            if (status.trim()) {\n                execSync(`git commit -m \"chore: update secrets for ${appName} (prod/test)\"`, { cwd: repoPath });\n                execSync(`git push origin main`, { cwd: repoPath });\n                return NextResponse.json({ message: \"Secrets updated successfully for both environments!\" });\n            } else {\n                return NextResponse.json({ message: \"No changes detected.\" });\n            }\n\n        } catch (err) {\n            console.error(err);\n            return NextResponse.json({ error: err.message }, { status: 500 });\n        }\n    });\n}"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAEO,MAAM,UAAU;AAEvB,MAAM,gBAAgB;IAClB,OAAO;QACH,aAAa;QACb,UAAU,4GAAI,CAAC,IAAI,CAAC,wGAAE,CAAC,MAAM,IAAI;QACjC,OAAO,QAAQ,GAAG,CAAC,YAAY;QAC/B,SAAS,QAAQ,GAAG,CAAC,iBAAiB;QACtC,UAAU,QAAQ,GAAG,CAAC,aAAa,IAAI;QACvC,WAAW,QAAQ,GAAG,CAAC,cAAc,IAAI;QACzC,WAAW,QAAQ,GAAG,CAAC,eAAe,IAAI;IAC9C;AACJ;AAEA,MAAM,iBAAiB,CAAC;IACpB,IAAI,CAAC,wGAAE,CAAC,UAAU,CAAC,WAAW,OAAO,EAAE;IACvC,IAAI;QACA,MAAM,UAAU,wGAAE,CAAC,YAAY,CAAC,UAAU;QAC1C,MAAM,SAAS,uMAAI,CAAC,IAAI,CAAC;QACzB,MAAM,UAAU,OAAO,UAAU,IAAI,CAAC;QACtC,OAAO,OAAO,IAAI,CAAC;IACvB,EAAE,OAAO,GAAG;QACR,QAAQ,KAAK,CAAC,CAAC,yBAAyB,EAAE,SAAS,CAAC,CAAC,EAAE,EAAE,OAAO;QAChE,OAAO,EAAE;IACb;AACJ;AAEA,MAAM,sBAAsB,CAAC,UAAU,YAAY;IAC/C,MAAM,MAAM,4GAAI,CAAC,OAAO,CAAC;IACzB,IAAI,CAAC,wGAAE,CAAC,UAAU,CAAC,MAAM,wGAAE,CAAC,SAAS,CAAC,KAAK;QAAE,WAAW;IAAK;IAE7D,IAAI;QACA,MAAM,eAAe,CAAC;QACtB,mDAAmD;QACnD,uCAAuC;QACvC,IAAI,MAAM,OAAO,CAAC,aAAa;YAC3B,WAAW,OAAO,CAAC,CAAA;gBACf,IAAI,EAAE,GAAG,IAAI,EAAE,KAAK,KAAK,WAAW,YAAY,CAAC,EAAE,GAAG,CAAC,GAAG,EAAE,KAAK;YACrE;QACJ,OAAO;YACH,OAAO,OAAO,CAAC,YAAY,OAAO,CAAC,CAAC,CAAC,GAAG,EAAE;gBACtC,IAAI,MAAM,WAAW,YAAY,CAAC,EAAE,GAAG;YAC3C;QACJ;QAEA,MAAM,MAAM;YAAE,YAAY;QAAa;QACvC,MAAM,UAAU,uMAAI,CAAC,IAAI,CAAC,KAAK;YAAE,WAAW,CAAC;QAAE;QAC/C,wGAAE,CAAC,aAAa,CAAC,UAAU;QAE3B,IAAA,+HAAQ,EAAC,CAAC,qBAAqB,EAAE,UAAU,gDAAgD,EAAE,SAAS,CAAC,CAAC;IAC5G,EAAE,OAAO,GAAG;QACR,MAAM,IAAI,MAAM,CAAC,oBAAoB,EAAE,4GAAI,CAAC,QAAQ,CAAC,UAAU,EAAE,EAAE,EAAE,OAAO,EAAE;IAClF;AACJ;AAEO,eAAe,IAAI,GAAG;IACzB,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,IAAI,GAAG;IACxC,MAAM,UAAU,aAAa,GAAG,CAAC;IACjC,IAAI,CAAC,SAAS,OAAO,yLAAY,CAAC,IAAI,CAAC;QAAE,OAAO;IAAoB,GAAG;QAAE,QAAQ;IAAI;IAErF,OAAO,MAAM,6KAAQ,CAAC,YAAY,CAAC;QAC/B,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,KAAK,EAAE,QAAQ,EAAE,SAAS,EAAE,GAAG;QAC1D,MAAM,mBAAmB,QAAQ,OAAO,CAAC,YAAY,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;QAExE,IAAI;YACA,IAAI,CAAC,wGAAE,CAAC,UAAU,CAAC,WAAW;gBAC1B,IAAA,+HAAQ,EAAC,CAAC,UAAU,EAAE,iBAAiB,CAAC,EAAE,UAAU;YACxD,OAAO;gBACH,IAAI;oBACA,IAAA,+HAAQ,EAAC,CAAC,gBAAgB,CAAC,EAAE;wBAAE,KAAK;oBAAS;oBAC7C,IAAA,+HAAQ,EAAC,CAAC,4BAA4B,CAAC,EAAE;wBAAE,KAAK;oBAAS;gBAC7D,EAAE,OAAO,GAAG;oBACR,wGAAE,CAAC,MAAM,CAAC,UAAU;wBAAE,WAAW;wBAAM,OAAO;oBAAK;oBACnD,IAAA,+HAAQ,EAAC,CAAC,UAAU,EAAE,iBAAiB,CAAC,EAAE,UAAU;gBACxD;YACJ;YACA,IAAA,+HAAQ,EAAC,CAAC,sBAAsB,EAAE,SAAS,CAAC,CAAC,EAAE;gBAAE,KAAK;YAAS;YAC/D,IAAA,+HAAQ,EAAC,CAAC,uBAAuB,EAAE,UAAU,CAAC,CAAC,EAAE;gBAAE,KAAK;YAAS;YAEjE,MAAM,WAAW,4GAAI,CAAC,IAAI,CAAC,UAAU;YACrC,MAAM,eAAe,4GAAI,CAAC,IAAI,CAAC,UAAU;YAEzC,IAAI,QAAQ;YACZ,IAAI,wGAAE,CAAC,UAAU,CAAC,eAAe;gBAC7B,IAAI;oBACA,MAAM,WAAW,KAAK,KAAK,CAAC,wGAAE,CAAC,YAAY,CAAC,cAAc;oBAC1D,MAAM,WAAW,SAAS,IAAI,CAAC,CAAA,IAAK,EAAE,IAAI,KAAK;oBAC/C,IAAI,UAAU,QAAQ,SAAS,EAAE;gBACrC,EAAE,OAAO,GAAG;oBAAE,QAAQ,KAAK,CAAC,4BAA4B;gBAAI;YAChE;YAEA,eAAe;YACf,IAAI,cAAc,4GAAI,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,EAAE,QAAQ,KAAK,CAAC,EAAE;YAClE,IAAI,cAAc,4GAAI,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,EAAE,QAAQ,QAAQ,CAAC,EAAE;YAErE,IAAI,aAAa,4GAAI,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,IAAI,EAAE,QAAQ,KAAK,CAAC,EAAE;YACpE,IAAI,aAAa,4GAAI,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,IAAI,EAAE,QAAQ,QAAQ,CAAC,EAAE;YAEvE,kBAAkB;YAClB,IAAI,CAAC,wGAAE,CAAC,UAAU,CAAC,4GAAI,CAAC,OAAO,CAAC,eAAe;gBAC3C,cAAc,4GAAI,CAAC,IAAI,CAAC,UAAU,GAAG,QAAQ,KAAK,CAAC,EAAE;gBACrD,oEAAoE;gBACpE,cAAc,4GAAI,CAAC,IAAI,CAAC,UAAU,GAAG,QAAQ,QAAQ,CAAC,EAAE;YAC5D;YACA,IAAI,CAAC,wGAAE,CAAC,UAAU,CAAC,4GAAI,CAAC,OAAO,CAAC,cAAc;gBAC1C,aAAa,4GAAI,CAAC,IAAI,CAAC,UAAU,GAAG,QAAQ,QAAQ,CAAC,EAAE;gBACvD,aAAa,4GAAI,CAAC,IAAI,CAAC,UAAU,GAAG,QAAQ,WAAW,CAAC,EAAE;YAC9D;YAEA,YAAY;YACZ,MAAM,cAAc,eAAe;YACnC,MAAM,cAAc,eAAe;YACnC,MAAM,aAAa,eAAe;YAClC,MAAM,aAAa,eAAe;YAElC,oBAAoB;YACpB,MAAM,YAAY,CAAC,OAAO,QAAU,MAAM,IAAI,CAAC,IAAI,IAAI;uBAAI;uBAAU;iBAAM;YAE3E,MAAM,aAAa,UAAU,aAAa;YAC1C,MAAM,YAAY,UAAU,YAAY;YAExC,MAAM,aAAa,WAAW,GAAG,CAAC,CAAA,IAAK,CAAC;oBAAE,KAAK;gBAAE,CAAC;YAClD,MAAM,YAAY,UAAU,GAAG,CAAC,CAAA,IAAK,CAAC;oBAAE,KAAK;gBAAE,CAAC;YAEhD,OAAO,yLAAY,CAAC,IAAI,CAAC;gBACrB;gBACA;gBACA,OAAO,wGAAE,CAAC,UAAU,CAAC,4GAAI,CAAC,OAAO,CAAC;YACtC;QAEJ,EAAE,OAAO,KAAK;YACV,QAAQ,KAAK,CAAC;YACd,OAAO,yLAAY,CAAC,IAAI,CAAC;gBAAE,OAAO,IAAI,OAAO;YAAC,GAAG;gBAAE,QAAQ;YAAI;QACnE;IACJ;AACJ;AAEO,eAAe,KAAK,GAAG;IAC1B,MAAM,EAAE,OAAO,EAAE,UAAU,EAAE,cAAc,EAAE,SAAS,EAAE,aAAa,EAAE,GAAG,MAAM,IAAI,IAAI;IACxF,IAAI,CAAC,SAAS,OAAO,yLAAY,CAAC,IAAI,CAAC;QAAE,OAAO;IAAmB,GAAG;QAAE,QAAQ;IAAI;IAEpF,OAAO,MAAM,6KAAQ,CAAC,YAAY,CAAC;QAC/B,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,KAAK,EAAE,QAAQ,EAAE,SAAS,EAAE,SAAS,EAAE,GAAG;QACrE,MAAM,mBAAmB,QAAQ,OAAO,CAAC,YAAY,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;QAExE,IAAI;YACA,IAAI,CAAC,wGAAE,CAAC,UAAU,CAAC,WAAW;gBAC1B,IAAA,+HAAQ,EAAC,CAAC,UAAU,EAAE,iBAAiB,CAAC,EAAE,UAAU;YACxD,OAAO;gBACF,IAAI;oBACD,IAAA,+HAAQ,EAAC,CAAC,gBAAgB,CAAC,EAAE;wBAAE,KAAK;oBAAS;oBAC7C,IAAA,+HAAQ,EAAC,CAAC,4BAA4B,CAAC,EAAE;wBAAE,KAAK;oBAAS;gBAC7D,EAAE,OAAO,GAAG;oBACR,wGAAE,CAAC,MAAM,CAAC,UAAU;wBAAE,WAAW;wBAAM,OAAO;oBAAK;oBACnD,IAAA,+HAAQ,EAAC,CAAC,UAAU,EAAE,iBAAiB,CAAC,EAAE,UAAU;gBACxD;YACJ;YACA,IAAA,+HAAQ,EAAC,CAAC,sBAAsB,EAAE,SAAS,CAAC,CAAC,EAAE;gBAAE,KAAK;YAAS;YAC/D,IAAA,+HAAQ,EAAC,CAAC,uBAAuB,EAAE,UAAU,CAAC,CAAC,EAAE;gBAAE,KAAK;YAAS;YAEjE,MAAM,WAAW,4GAAI,CAAC,IAAI,CAAC,UAAU;YACrC,MAAM,eAAe,4GAAI,CAAC,IAAI,CAAC,UAAU;YAEzC,IAAI,QAAQ;YACZ,IAAI,wGAAE,CAAC,UAAU,CAAC,eAAe;gBAC7B,IAAI;oBACA,MAAM,WAAW,KAAK,KAAK,CAAC,wGAAE,CAAC,YAAY,CAAC,cAAc;oBAC1D,MAAM,WAAW,SAAS,IAAI,CAAC,CAAA,IAAK,EAAE,IAAI,KAAK;oBAC/C,IAAI,UAAU,QAAQ,SAAS,EAAE;gBACrC,EAAE,OAAO,GAAG;oBAAE,QAAQ,KAAK,CAAC,4BAA4B;gBAAI;YAChE;YAEA,MAAM,WAAW,CAAC;gBACd,IAAI,OAAO,4GAAI,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,EAAE,SAAS,OAAO,QAAQ,KAAK,QAAQ,KAAK,CAAC,EAAE;gBACxF,IAAI,OAAO,4GAAI,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,EAAE,SAAS,OAAO,QAAQ,KAAK,QAAQ,QAAQ,CAAC,EAAE;gBAE3F,eAAe;gBACf,IAAI,CAAC,wGAAE,CAAC,UAAU,CAAC,4GAAI,CAAC,OAAO,CAAC,QAAQ;oBACpC,OAAO,4GAAI,CAAC,IAAI,CAAC,UAAU,GAAG,SAAS,OAAO,KAAK,KAAK,UAAU,SAAS,OAAO,QAAQ,GAAG,KAAK,CAAC,EAAE,iBAAiB,2DAA2D;oBACjL,6BAA6B;oBAC7B,IAAI,CAAC,wGAAE,CAAC,UAAU,CAAC,4GAAI,CAAC,OAAO,CAAC,4GAAI,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,EAAE,SAAS,OAAO,QAAQ,KAAK,QAAQ,KAAK,CAAC,KAAK;wBAC3G,iBAAiB;wBACjB,MAAM,aAAa,4GAAI,CAAC,IAAI,CAAC,UAAU,GAAG,UAAU,SAAS,OAAO,QAAQ,IAAI;wBAChF,OAAO,aAAa;wBACpB,OAAO,aAAa;oBACzB;gBACJ;gBACA,OAAO;oBAAE;oBAAM;gBAAK;YACxB;YAEA,cAAc;YACd,MAAM,WAAW,SAAS;YAC1B,IAAI,cAAc,WAAW,MAAM,GAAG,GAAG,oBAAoB,SAAS,IAAI,EAAE,YAAY;YACxF,IAAI,kBAAkB,eAAe,MAAM,GAAG,GAAG,oBAAoB,SAAS,IAAI,EAAE,gBAAgB;YAEpG,aAAa;YACb,MAAM,UAAU,SAAS;YACzB,IAAI,aAAa,UAAU,MAAM,GAAG,GAAG,oBAAoB,QAAQ,IAAI,EAAE,WAAW;YACpF,IAAI,iBAAiB,cAAc,MAAM,GAAG,GAAG,oBAAoB,QAAQ,IAAI,EAAE,eAAe;YAEhG,IAAA,+HAAQ,EAAC,CAAC,SAAS,CAAC,EAAE;gBAAE,KAAK;YAAS;YACtC,MAAM,SAAS,IAAA,+HAAQ,EAAC,CAAC,sBAAsB,CAAC,EAAE;gBAAE,KAAK;YAAS,GAAG,QAAQ;YAE7E,IAAI,OAAO,IAAI,IAAI;gBACf,IAAA,+HAAQ,EAAC,CAAC,yCAAyC,EAAE,QAAQ,aAAa,CAAC,EAAE;oBAAE,KAAK;gBAAS;gBAC7F,IAAA,+HAAQ,EAAC,CAAC,oBAAoB,CAAC,EAAE;oBAAE,KAAK;gBAAS;gBACjD,OAAO,yLAAY,CAAC,IAAI,CAAC;oBAAE,SAAS;gBAAsD;YAC9F,OAAO;gBACH,OAAO,yLAAY,CAAC,IAAI,CAAC;oBAAE,SAAS;gBAAuB;YAC/D;QAEJ,EAAE,OAAO,KAAK;YACV,QAAQ,KAAK,CAAC;YACd,OAAO,yLAAY,CAAC,IAAI,CAAC;gBAAE,OAAO,IAAI,OAAO;YAAC,GAAG;gBAAE,QAAQ;YAAI;QACnE;IACJ;AACJ"}}]
}