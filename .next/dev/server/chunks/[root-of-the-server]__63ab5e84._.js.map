{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///home/duwa/Git/webui-devops/Naratel-Devops-Dashboard/src/lib/gitMutex.js"],"sourcesContent":["import { Mutex } from 'async-mutex';\n\n// Shared mutex instance to prevent race conditions during Git operations\nexport const gitMutex = new Mutex();\n"],"names":[],"mappings":";;;;AAAA;;AAGO,MAAM,WAAW,IAAI,wMAAK"}},
    {"offset": {"line": 81, "column": 0}, "map": {"version":3,"sources":["file:///home/duwa/Git/webui-devops/Naratel-Devops-Dashboard/src/app/api/manifest/secrets/route.js"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { execSync } from 'child_process';\nimport fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport yaml from 'js-yaml';\nimport { gitMutex } from '@/lib/gitMutex';\n\nexport const dynamic = 'force-dynamic';\n\nconst getRepoConfig = () => {\n    return {\n        repoDirName: 'manifest-repo-workdir',\n        repoPath: path.join(os.tmpdir(), 'manifest-repo-workdir'),\n        token: process.env.GITHUB_TOKEN,\n        repoUrl: process.env.MANIFEST_REPO_URL,\n        userName: process.env.GIT_USER_NAME || \"Naratel DevOps Dashboard\",\n        userEmail: process.env.GIT_USER_EMAIL || \"devops@naratel.com\",\n        agePubKey: process.env.SOPS_AGE_PUBKEY || \"age1ywhtcmyuhmfa32kfaaxcak4dvq27q9g6m55gqlzu2vlwkgfj24wq3g4ejx\"\n    };\n};\n\nconst readSecretKeys = (filePath) => {\n    if (!fs.existsSync(filePath)) return {};\n    try {\n        const content = fs.readFileSync(filePath, 'utf8');\n        const parsed = yaml.load(content);\n        const secrets = parsed.secretData || {};\n        \n        const result = {};\n        Object.keys(secrets).forEach(k => {\n            result[k] = \"\"; \n        });\n        return result;\n    } catch (e) {\n        console.error(`Failed to read keys from ${filePath}:`, e.message);\n        return {};\n    }\n};\n\nexport async function GET(req) {\n    const { searchParams } = new URL(req.url);\n    const appName = searchParams.get('appName');\n    if (!appName) return NextResponse.json({ error: \"App Name required\" }, { status: 400 });\n\n    return await gitMutex.runExclusive(async () => {\n        const { repoPath, repoUrl, token, userName, userEmail } = getRepoConfig();\n        const authenticatedUrl = repoUrl.replace(\"https://\", `https://${token}@`);\n\n        try {\n            if (!fs.existsSync(repoPath)) {\n                execSync(`git clone ${authenticatedUrl} ${repoPath}`);\n            } else {\n                try {\n                    execSync(`git fetch origin`, { cwd: repoPath });\n                    execSync(`git reset --hard origin/main`, { cwd: repoPath });\n                } catch (e) {\n                    fs.rmSync(repoPath, { recursive: true, force: true });\n                    execSync(`git clone ${authenticatedUrl} ${repoPath}`);\n                }\n            }\n            execSync(`git config user.name \"${userName}\"`, { cwd: repoPath });\n            execSync(`git config user.email \"${userEmail}\"`, { cwd: repoPath });\n\n            const appsPath = path.join(repoPath, 'apps');\n            \n            // TARGET secrets.yaml (PROD ONLY)\n            const appProdPath = path.join(appsPath, `${appName}-prod`, 'secrets.yaml');\n            const dbProdPath = path.join(appsPath, `${appName}-db-prod`, 'secrets.yaml');\n\n            const appProdKeys = readSecretKeys(appProdPath);\n            \n            // Check based on folder existence, assuming db folder implies db exists\n            const dbProdFolder = path.dirname(dbProdPath);\n            const dbExists = fs.existsSync(dbProdFolder);\n            \n            const dbProdKeys = dbExists ? readSecretKeys(dbProdPath) : {};\n\n            const mapKeys = (prodObj) => {\n                const keys = Object.keys(prodObj);\n                const result = [];\n                keys.forEach(key => {\n                    result.push({ key, valueProd: \"\" });\n                });\n                return result;\n            };\n\n            const appSecretsMerged = mapKeys(appProdKeys);\n            const dbSecretsMerged = mapKeys(dbProdKeys);\n\n            return NextResponse.json({\n                appSecrets: appSecretsMerged,\n                dbSecrets: dbSecretsMerged,\n                hasDb: dbExists,\n                mode: \"overwrite\"\n            });\n\n        } catch (err) {\n            console.error(err);\n            return NextResponse.json({ error: err.message }, { status: 500 });\n        }\n    });\n}\n\nconst overwriteSecretFile = (filePath, newSecrets, agePubKey) => {\n    // If file doesn't exist (migration case), create it?\n    // Generator ensures it exists for NEW apps.\n    // For OLD apps, we might need to create it.\n    // Let's create it if directory exists.\n    const dir = path.dirname(filePath);\n    if (!fs.existsSync(dir)) return;\n\n    try {\n        const cleanSecrets = {};\n        Object.entries(newSecrets).forEach(([k, v]) => {\n            if (v !== undefined && v !== null) {\n                cleanSecrets[k] = v;\n            }\n        });\n\n        // Always reconstruct minimal structure\n        const doc = { secretData: cleanSecrets };\n\n        const newYaml = yaml.dump(doc, { lineWidth: -1 });\n        fs.writeFileSync(filePath, newYaml);\n\n        // Encrypt using PUBLIC KEY\n        execSync(`sops --encrypt --age ${agePubKey} --encrypted-regex '^(secretData)$' --in-place \"${filePath}\"`);\n        \n    } catch (e) {\n        throw new Error(`Failed to overwrite ${path.basename(filePath)}: ${e.message}`);\n    }\n};\n\nexport async function POST(req) {\n    const { appName, appSecrets, dbSecrets } = await req.json();\n    if (!appName) return NextResponse.json({ error: \"Missing App Name\" }, { status: 400 });\n\n    return await gitMutex.runExclusive(async () => {\n        const { repoPath, repoUrl, token, userName, userEmail, agePubKey } = getRepoConfig();\n        const authenticatedUrl = repoUrl.replace(\"https://\", `https://${token}@`);\n\n        try {\n            if (!fs.existsSync(repoPath)) {\n                execSync(`git clone ${authenticatedUrl} ${repoPath}`);\n            } else {\n                 try {\n                    execSync(`git fetch origin`, { cwd: repoPath });\n                    execSync(`git reset --hard origin/main`, { cwd: repoPath });\n                } catch (e) {\n                    fs.rmSync(repoPath, { recursive: true, force: true });\n                    execSync(`git clone ${authenticatedUrl} ${repoPath}`);\n                }\n            }\n            execSync(`git config user.name \"${userName}\"`, { cwd: repoPath });\n            execSync(`git config user.email \"${userEmail}\"`, { cwd: repoPath });\n\n            const appsPath = path.join(repoPath, 'apps');\n            \n            // --- PROCESS APP SECRETS (PROD ONLY) ---\n            if (appSecrets && Array.isArray(appSecrets)) {\n                const appProdObj = {};\n                appSecrets.forEach(s => {\n                    if (s.key) {\n                        if (s.valueProd !== undefined && s.valueProd !== null) appProdObj[s.key] = s.valueProd;\n                    }\n                });\n\n                const appProdPath = path.join(appsPath, `${appName}-prod`, 'secrets.yaml');\n                overwriteSecretFile(appProdPath, appProdObj, agePubKey);\n            }\n\n            // --- PROCESS DB SECRETS (PROD ONLY) ---\n            if (dbSecrets && Array.isArray(dbSecrets)) {\n                const dbProdObj = {};\n                dbSecrets.forEach(s => {\n                    if (s.key) {\n                        if (s.valueProd !== undefined && s.valueProd !== null) dbProdObj[s.key] = s.valueProd;\n                    }\n                });\n\n                const dbProdPath = path.join(appsPath, `${appName}-db-prod`, 'secrets.yaml');\n                // Only overwrite if paths exist (or just try, the helper handles check)\n                overwriteSecretFile(dbProdPath, dbProdObj, agePubKey);\n            }\n\n            execSync(`git add .`, { cwd: repoPath });\n            const status = execSync(`git status --porcelain`, { cwd: repoPath }).toString();\n            \n            if (status.trim()) {\n                execSync(`git commit -m \"chore: update secrets for ${appName} (overwrite)\"`, { cwd: repoPath });\n                execSync(`git push origin main`, { cwd: repoPath });\n                return NextResponse.json({ message: \"Secrets overwritten and encrypted successfully!\" });\n            } else {\n                return NextResponse.json({ message: \"No changes detected.\" });\n            }\n\n        } catch (err) {\n            console.error(err);\n            return NextResponse.json({ error: err.message }, { status: 500 });\n        }\n    });\n}\n"],"names":[],"mappings":"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"}}]
}